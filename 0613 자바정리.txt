Math.random()	-> 실행 할 때마다 난수 발생(값이 달라진다)
0<=	Math.random() <1
0<=	Math.random()*45 <45
0<= > 		<45
(int)44.9999 -> 44

0<=	(int)(Math.random()*45) <45
0<=? <45

lotto 배열에서 1부터 45까지 저장

01234 ~ 44 배열 lotto의 번지
idx=번지
int box=0; //임시 저장공간
box=lotto[idx];
lotto[idx]=lotto[0];
lotto[0]=box;



배열
1. 같은 타입의 data를 순서대로 그룹화
2. 인덱스 (번지, 요소)는 0번지부터 시작된다.
3. 배열의 갯수는 고정한다. >> 컬렉션.. 고정X
4. 배열의 참조형 타입(배열의 전체 주소값으로 접근).. new 배열
5. 배열의 생성과 동시에 초기화 해야된다.
6. 값을 초기화하지 않으면 0으로 초기화 된다.
7. 반복문(for)과 같이 많이 사용된다.
8. 전체 배열의 data의 갯수는 전체 인덱스 총 수보다 1크다.
9. 배열 이름에 전체 배열의 주소값을 저장
10 foreach (DB의 data를 가져올 때)

Object obj=new Object();
obj 	-> 객체 접근 연산자
	-> 객체가 가지고 있는 속성이나 매서드에 접근 할 수 있다.
obj.속성;
obj매서드();


** 모든 클래스는 Object클래스를 상속(inheritance) 받는다.
** 모든 클래스는 Object클래스의 모든 속성과 매서드를 상속 받았다. -> 사용할수있다.


배열


*** get -> "가져온다"
*** set -> "설정한다"

객체 타입의 반복문 foreach문
-> JSP, javascript.. 대부분의 프로그램 언어에서 객체형의 리스트(list)에 적용

for(객체타입 변수:객체) {
	 //변수 -> 모든 객체 요소를 get
}
for문 차이는 for문 갯수를 정해야된다.

== 다차원 배열 (행,열) ==

1. 전체 배열 접근 배열의 이름으로 접근
2. 각각의 배열의 행 배열 이름[]
3. 각각의 배열의 열은 배열 이름[행][]

4행3열
int[][] arrInt = new int[4][3];

arrInt[0]<< 첫번째 행
arrInt[0][0]<< 0행0열 "행 먼저 찾고" 


new int[]{1,2,3,4};
new int[]{1,2,3,4}, {5,6,7,8}, {9,10,11,12};
int[][] arr1=new int


1. 절차 지향 언어와 객체 지향 언어
절차 지향 언어 : 작업순서(알고리즘)을 표현(함수들의 집합으로 프로그래밍)
ex) C언어
객체 지향 언어 : 미리 사용할 목적으로 설계도(클래스)를 완성하고 그 객체를 이용해서 프로그래밍
ex) JAVA, C++

== 객체지향언어의 목적 ==
. 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
. 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
. 소프트웨어 재사용과 부분 수정 빠름
. 소프트웨어 생산성 향상

1) 객체 모델링
2) 클래스를 설계
3) 프로그래밍

세상 모든 것이 객체다

클래스 : "객체를 생성하기 위한 설계도(틀)", "객체의 속성과 기능 선언"
//클래스에 대한 접근 권한/클래스 선언/클래스 이름
//접근제한자(지정한) class 클래스명(첫글자대문)
public class Circle {
	// 필드+매서드 -> 멤버
	// 필드(속)
	public int radius;
	public String name;

	//메서드
	public double getArea() {
	
	}
}

객체(Object, 인스턴스(Instance)) : 실제, 추상 >> 모든것... "클래스를 통해서 현실화된 사물"
객체 멤버 : 속성(필드, 프로피터), 매서드(기능)

객체, 인스턴스
객체
인스턴스(클래스를 통해서 만들어진 것) : 클래스의 인스턴스

java type
1. primitive -> 기본 타입
	1	2	4	8
정수형	byte	short	int	long
실수형			float	double
문자형		char
논리형	boolean

1. 필드
인스턴스멤버 : 객체가 생성되면 생성되고 객체가 소멸되면 종료
클래스멤버 : 클래스가 생성되면 생성되고 클래스가 소멸되면 종료
클래스타입 객체참조변수 =new 생성자();
//인스턴스화(객체화)
String str=new String("manso");
str.멤버;

2. 멤버(매서드)

접근제한자 반환타입 매서명(입력인자) {
return 반환값; //반환값이 없으면 생략
}
public void instanceMethod(String name) {//인스턴스 매서드

	System.out.println(name+"인스턴스매서드2");


** 클래스 명명 규칙
1. 대문자로 시작한다(약속)
2. 한글을 사용하지 말자(약속)
3. 특수기호는 _$ 이외에는 사용할 수 없다.
4. 공백을 허용하지 않는다.
5. 단어단어의 첫 글자는 대문자로 시작한다(권고)

== 클래스 구성 ==
접근 제한자 class 클래스 (
	접근제한자 필드; //프로피티, 속성
	접근제한자 필드;
	접근제한자 매서드;
}
== 클래스 멤버 ==
1. 필드(멤버변수, 프로피티)
인스턴스 멤버 : 객체가 생성되면 생성되고 객체가 소멸되면 종료
클래스 멤버 : 클래스가 생성되면 생성되고 클래스가 소멸되면 종료

인스턴스 멤버는 new라는 키워드를 통해 힙이라는 영역에 존재
클래스 멤버는 -공유 가능

2. 매서드(함수, 기능)
접근제한자 반환타입 메소드(입력인자) {
	return 반환값;
}

class 멤버
필드	인스턴스, 클래스
매서드	인스턴스, 클래스

***static 멤버 (클래스 멤버)
>> 클래스당 하나만 생성
>> 객체들에 의해 공유됨 ★★  클래스이름, 클래스 멤버
>> 프로그램이 종료될 때 사라짐

***instanse 멤버 -> 객체를 생성한 후(인스턴스화)에 사용 가능
>> 객체별로 별도 존재
>> 객체 생성 시에 멤버 생성됨
>> 공유되지 않음 ★★
>> 객체 사라지면 멤버도 사라짐

클래스의 멤버

필드 -> 하나의 값을 setting 하거나, get
매서드 -> 어떤 기능, 처리, 구현, 호출
	** return문을 만나면 종료
	** 구현부가 있으면 구현하고 return값을 반환하고 종료
	** call(호출) 할때마다 새로 생성된다.

클래스
i)	public : 외부 어디서나 접근 가능(다른 패키지에서도 접근 가능)
ii)	private : 해당 클래스에서마 접근 가능(캡슐화)
iii)	protected : 해당 클래스 + 자식 클래스에서 접근 가능(상속관계)
iiii)	default : 자바 패키지 내에서 접근 가능

메소드/변수 (클래스 멤버)
i)	public : 외부 어디서나 접근 가능
ii)	private : 해당 클래스에서만 접근가능(캡슐화)
iii)	protected : 해당 클래스 + 자식 클래스에서 접근 가능 ★
iiii)	default : 자바 패키지 내에서 접근 가능

클래스
접근제한자 class 클래스명 {
	멤버;
}

매서드
//선언부
접근제한자 반환타입 매서드(입력인자) {
	//구현부
	return 반환값;
}

// 매서드 유형1
// void return값이 없다. 생략가능
public void 매서드명() {
	//구현부
	//return;
}

// 매서드 유형2
public void method2(int num1, int num2) {
	// 입력 값이 있다.
	int sum=num1+num2;// 매서드 안에 선언된 변수(지역변수)
	//return
}

// 매서드 유형3
// 반환타입 -> 반드시 return값이 있어야 된다.
public int method3() {
	return 반환값(반환타입과 타입이 일치);
}

// 매서드 유형4
// 반환타입 -> 반드시 return값이 있어야 된다.
public int method4(입력) {
	//구현부
	return 반환값(반환타입과 타입이 일치);
}

반환타입
//void return값 없다. 생략 가능
public void 매서드명(타입 변수) {
	return;
}

this -> 객체 자신
this.멤버;
this.필드;
this.매서드();

지역변수는 매서드 호출 시 생성되고 종료 시 사라진다(가비지 컬렉션)

** 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
객체의 가장 본질적인 특징
외부의 접근으로부터 객체 보호

** 자바의 캡슐화
클래스(class) : 객체 모양을 선언한 틀(캡슐화하는 틀)
객체 : 생성된 실제(instance)
클래스 내에 메소드와 필드 구현

프로그래밍 언어 -> 컴퓨터와 대화하는 언어

컴파일 언어 -> 번역(책)  C,JAVA

사람	컴파일	컴퓨터
source	컴파일러	기계어 0 1

source	컴파일 .class  실행

에러(error) -> JAVA는 엄격하다.
컴파일 에러 -> 프로그램 실행전에 에러 -> 프로그램이 실행이 안됨
런타임 에러 -> 프로그램인 실행 중에 에러 -> Exception(예외) : 무시할 수 있는 에러(작은 에러) -> 예외 처리

비컴파일언어(인터프리터언어): 한줄씩 해석
-> 인터프리터 -> javascript(브라우저에 내장 되어 있는 인터프리터)

	<접근가능 여부>
static	>>>>	static (O)
instance	>>>>	static (O)
static	>>>>	instance(X) -> static매서드에서는 instance멤버 X

static멤버(클래스 멤버) -> 엄격하다.


== 접근 제한자(modify) ==
public 모든 클래스에서 접근 가능(공용)
privite 같은 클래스 내에서만 접근 가능



** 기본적으로 프로그래밍언어에서 이름(매서드, 변수)같은 경우 같은 기억 공간에서는 
 허용 되지 않는다.
** 다만 예외적으로 자바에서 매서드 오버로딩을 허용하고
== 메소드 오버로딩 ==	** 매서드명, 타입, 매개변수 갯수가 완전히 일치하면 허용 X
오버로딩 (Overloading)
한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
. 메소드 이름이 동일하여야 함
. 매개 변수의 개수가 서로 다르거나, 타입이 서로 달라야 함
. 리턴 타입은 오버로딩과 관련 없음

자바에서 허용..
오버로딩 "매서드의 이름이 같고 매개변수 유형이 다른 매서드를 허용"

생성자 오버로딩...

*** 클래스, 멤버, 필드, static, instance, private, 매서드
*** 생성자(contruct), 상속, 추상클래스, 인터페이스
*** 패키지, 접근제한자(지정자), 오버로딩(매서드), 오버라이딩, 다행성














